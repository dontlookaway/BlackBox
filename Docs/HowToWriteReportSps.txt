/*
This is a guide on how to create a new report stored procedure for use in the blackbox database

General Overview of Procedures
	Each of the procedures runs in essentially the same process
	* create temporary mirrors of sysprocompany tables 
	* iterate through each sysprocompany database and populate the temporary mirrors
		> the reason to do this is that dynamic SQL must be used to choose which DB to execute against, when using dynamic sql no optimisation is performed. Therefore the smallest queries are run against the DB's and then the joins/selects are done locally.
	* create a temporary table for results
	* generate results into temporary tables
	* return results
	
Schema Name
	The schema for reports is Report

Procedure name
	User Stored Procedures are prefixed with Usp and then the action that the stored procedure performs. Most report stored procedures return Results, so the prefix is UspResults. 
	
	The second part of the stored procedure is used to identify the procedure. This should either reflect the system tables referred to or the final report that has been requested.
	
	For example, a new stored procedure for a report called ApAging that queried a table called ApInvoice could be called either
	
	> UspResults_ApAging
	> UspResults_ApInvoice
	
	The general rule is that if the dataset could have a use in other reports than to use the tables instead of the report name, but this rule is not hard and fast

Parameters
	There are 3 parameters that must be in all reports
	
	> @Company 			- choose which company to run against, ALL will run against all SysproCompany dbs, whilst a number/letter will run against the SysproCompany ending with that character
	> @RedTagType 		- this is set using the SQL command function in crystal reports and should not be directly available to users, look at the the table [Lookups].[RedTagsUsedByType] for the letters that can be used, if this is left as blank/null it will default to the code X
	> @RedTagUse 		- this is set using the SQL command function in crystal reports and should not be directly available to users, this should be the name of the report so that it can be tracked, the folders should also be included in this. For example "Development > Chris Johnson > SomeReportName"
	
	Other parameters can be added as required, however dynamic crystal parameters cannot be passed to SQL commands, so required values must be manually input by the user running the report. For 
	
NoCount
	As there are a lot of rows being read and written, setting nocount to "on" until returning the results reduces the amount of errors generated by counts being returned before the dataset

Upper(@Company)
	Because the SQL server is case sensitive, letters entered are cast to uppercase to ensure code runs
	
[Process].[UspInsert_RedTagLogs]
	This stored procedure captures tracking information into the table [History].[RedTagLogs]
	Parameters
	> @StoredProcDb 		- this should be set to the database of the procedure being created/amended
	> @StoredProcSchema 	- this should be set to the schema of the procedure being created/amended
	> @StoredProcName 		- this should be set to the name of the procedure being created/amended
	> @UsedByType 			- should be set to @RedTagType 
	> @UsedByName 			- should be set to @RedTagUse
	> @UsedByDb 			- should be set to @RedTagDB

@ListOfTables	
	Enter the sysprocompany tables that should be queried, this ensures that only tables that exist can be queried
	
Temporary tables
	Define the fields to bring back from each table here, remember to include a database reference for linking
	
Declare @SQL
	within the BEGIN and END of the statement, enter the insert statement into the temporary table from the database table
	> usually this is declared for each table to make it easier to read
	
[Process].[ExecForEachDB_WithTableCheck] 
	This is procedure built to replace sp_MSforeachdb as the microsoft function is not supported.
	> @cmd 					- this is the code to be run against each db, use the @SQL variables
	> @SchemaTablesToCheck 	- this checks that @ListOfTables exists before trying to run the code
*/

/*SQL Code to alter*/
Alter Proc [Report].[UspResults_Template]
 ( @Company Varchar(Max) 
     , @RedTagType Char(1)
    , @RedTagUse Varchar(500)
    )
As
    Begin
/*
Template designed by Chris Johnson, Prometic Group September 2015
Stored procedure set out to query multiple databases with the same information and return it in a collated format
*/
Set NoCount On

        If IsNumeric(@Company) = 0
            Begin
                Select  @Company = Upper(@Company);
            End;

--Red tag
        Declare @RedTagDB Varchar(255)= Db_Name();
        Exec [Process].[UspInsert_RedTagLogs] @StoredProcDb = 'BlackBox' ,
            @StoredProcSchema = 'Report' ,
            @StoredProcName = 'UspResults_Template' ,
            @UsedByType = @RedTagType , @UsedByName = @RedTagUse ,
            @UsedByDb = @RedTagDB;

--list the tables that are to be pulled back from each DB - if they are not found the script will not be run against that db
        Declare @ListOfTables Varchar(Max) = 'AssetDepreciation,TblApTerms'; 

--create temporary tables to be pulled from different databases, including a column to id
        Create Table [#Table1]
            (
              [DatabaseName] Varchar(150)
            , [ColumnName] Varchar(500)
            );

	

--create script to pull data from each db into the tables
        Declare @SQL Varchar(Max) = '
	USE [?];
	Declare @DB varchar(150),@DBCode varchar(150)
	Select @DB = DB_NAME(),@DBCode = case when len(db_Name())>13 then right(db_Name(),len(db_Name())-13) else null end
	IF left(@DB,13)=''SysproCompany'' and right(@DB,3)<>''SRS''
	BEGIN
		IF @DBCode in (''' + Replace(@Company , ',' , ''',''') + ''') or '''
            + Upper(@Company) + ''' = ''ALL''
			BEGIN
				Insert [#Table1]
						( [DatabaseName], [ColumnName] )
				SELECT [t].[DatabaseName]
					 , [t].[ColumnName] 
				FROM [#Table1] As [t]
			End
	End';

--Enable this function to check script changes (try to run script directly against db manually)
--Print @SQL

--execute script against each db, populating the base tables
        Exec [Process].[ExecForEachDB_WithTableCheck] @cmd = @SQL , 
            @SchemaTablesToCheck = @ListOfTables


--define the results you want to return
        Create Table [#Results]
            (
              [DatabaseName] Varchar(150)
            , [Results] Varchar(500)
            );

--Placeholder to create indexes as required

--script to combine base data and insert into results table
        Insert  [#Results]
                ( [DatabaseName]
                , [Results]
                )
                Select  [DatabaseName]
                      , [ColumnName]
                From    [#Table1];

Set NoCount Off
--return results
        Select  *
        From    [#Results];

    End;

GO
